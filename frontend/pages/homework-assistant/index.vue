<template>
  <PageWrapper title="Homework Assistant">
    <transition
      @before-leave="beforeLeave"
      @leave="leave"
      appear
    >
      <FileUploadCard @upload="handleUpload"/>
    </transition>
    <div class="flex flex-col min-w-full overflow-hidden">
      <div>
        <Card v-for="task in extractedTasks" :key="task.id" class="mb-4">
          <CardHeader>
            <CardTitle>{{ task.key }}</CardTitle>
            <CardDescription>{{ task.description }}</CardDescription>
          </CardHeader>
          <CardContent>
            <MarkdownComponent :content="task.description"/>
          </CardContent>

        </Card>
      </div>
      <!-- Explanation Section -->
      <Card class="h-full flex flex-col ">
        <CardHeader>
          <CardTitle>Explanation</CardTitle>
          <CardDescription>
            Below you can see a simple explanation of the assignment generated by our AI.
          </CardDescription>
        </CardHeader>
        <CardContent class="flex-1 flex flex-col">
          <MarkdownComponent :content="currentHomeworkAssistanceRun?.explanation || ''"/>
          <!-- Chat -->
          <div class="flex flex-col flex-1 bg-white dark:bg-gray-900 rounded-lg ">
            <!-- Messages -->
            <div
              ref="container"
              class="flex-1 overflow-y-auto space-y-4 px-4 pt-4"
            >
              <div
                v-for="(msg, i) in messages"
                :key="i"
                class="flex items-start"
                :class="msg.from === 'user' ? 'justify-end' : 'justify-start'"
              >
                <div
                  class="max-w-[80%] py-2 px-4 rounded-xl prose dark:prose-invert"
                  :class="msg.from === 'user'
                ? 'bg-blue-600 text-white rounded-br-none'
                : 'dark:bg-gray-800 text-gray-900 dark:text-gray-100 rounded-bl-none'"
                >
                  <MarkdownComponent :content="msg.content" />
                </div>
              </div>

              <!-- Typing Indicator -->
              <div v-if="loading" class="flex items-center">
                <div class="flex space-x-1">
                  <span class="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce-delay-0"></span>
                  <span class="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce-delay-200"></span>
                  <span class="w-2 h-2 bg-gray-400 dark:bg-gray-600 rounded-full animate-bounce-delay-400"></span>
                </div>
              </div>
            </div>

            <div class="-mx-6 -mb-6 mt-4 rounded-lg overflow-hidden">
            <!-- Input Area -->
            <div class="px-4 py-3 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800 flex items-center space-x-2">
          <Textarea
            v-model="draft"
            placeholder="Type your message..."
            class="flex-1 resize-none"
            rows="1"
            @keydown.enter.stop.prevent="sendMessage"
            @input="autoResize"
          />
              <Button :disabled="!draft || loading" @click="sendMessage">
                Send
              </Button>
              <Button v-if="loading" variant="outline" size="sm" class="text-red-500" @click="stopGeneration">
                Stop
              </Button>
            </div>
          </div>
          </div>
        </CardContent>
      </Card>
    </div>

      <!-- Chat Section -->
  </PageWrapper>
</template>

<script setup lang="ts">
import { Textarea } from '@/components/ui/textarea'
import { Button } from '@/components/ui/button'
import MarkdownComponent from '~/components/MarkdownComponent.vue'
import { useRuntimeConfig } from '#imports'
import {useHomeworkAssistantStore} from "~/stores/homework-assistant-store";
import {HomeworkService} from "~/src/client";

const homeworkAssitantRunId = ref<string | null>(null)
const userStore = useUserStore()
const homeworkAssistantStore = useHomeworkAssistantStore()
const { selectedFile } = storeToRefs(homeworkAssistantStore)
await userStore.fetchUser()
const extractedTasks = ref(null)

async function handleUpload() {
  if (!selectedFile.value) return

  const formData = new FormData()
  formData.append('file', selectedFile.value)

  const baseUrl = useRuntimeConfig().public.apiBase
  const res = await fetch(`${baseUrl}/user/${userStore.currentUser.id}/upload-homework`, {
    method: 'POST',
    body: formData,
  })

  if (!res.ok) {
    console.error(await res.text())
    return
  }

  const result = await res.json()
  homeworkAssitantRunId.value = result.homework_assistance_run_id
  await pollWorkflowSteps(result.homework_assistance_run_id)
}

interface Message {
  from: 'user' | 'assistant'
  content: string
}

const messages = ref<Message[]>([])
const draft = ref('')
const loading = ref(false)
let controller: AbortController | null = null
const container = ref<HTMLElement | null>(null)
const pollingInterval = 2000 // ms
let pollingTimer: number | null = null

const completedSteps = ref<Set<string>>(new Set())

interface StepResultMap {
  explanation: string
}

const currentHomeworkAssistanceRun = ref(null)

async function pollWorkflowSteps(runId: string) {
  const baseUrl = useRuntimeConfig().public.apiBase

  const poll = async () => {
    try {
      const res = await fetch(`${baseUrl}/homework-assistant/status/${runId}`)
      if (!res.ok) {
        console.error("Polling failed", await res.text())
        return
      }

      const data = await res.json()
      const steps = data.step_states || []
      console.log(steps)

      let allDone = true

      for (const step of steps) {
        const { name, state } = step


        if (state === 'SUCCEEDED' && !completedSteps.value.has(name)) {
          if (name === "EXTRACT_TASKS") {
            const {data}= await HomeworkService.getHomeworkAssistanceRunTasks({path: {homework_assistance_run_id: runId}})
            extractedTasks.value = data?.tasks
            console.log(extractedTasks.value)
          }
          const res = await fetch(`${baseUrl}/homework-assistant/${runId}`)
          const result = await res.json()

          currentHomeworkAssistanceRun.value = result
          console.log(currentHomeworkAssistanceRun.value)

          completedSteps.value.add(name)
        }

        if (state !== 'SUCCEEDED') {
          allDone = false
        }
      }

      if (allDone) {
        console.log('All steps completed')
        clearInterval(pollingTimer!)
        pollingTimer = null
      }

    } catch (e) {
      console.error("Polling error:", e)
      clearInterval(pollingTimer!)
    }
  }

  pollingTimer = window.setInterval(poll, pollingInterval)
}


function autoResize(event: Event) {
  const el = event.target as HTMLTextAreaElement
  el.style.height = 'auto'
  el.style.height = el.scrollHeight + 'px'
}

async function sendMessage() {
  const text = draft.value.trim()
  if (!text) return
  messages.value.push({ from: 'user', content: text })
  draft.value = ''
  loading.value = true

  controller = new AbortController()
  const charDelay = 30
  let assistantContent = ''

  const baseUrl = useRuntimeConfig().public.apiBase
  const runId = 'your-homework-run-id' // TODO: inject this properly

  const jsonMessages = JSON.stringify(messages.value.map(m => ({ role: m.from, content: m.content })))

  try {
    const response = await fetch(`${baseUrl}/homework-assistant/chat/${runId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: jsonMessages,
      signal: controller.signal,
    })

    if (!response.ok || !response.body) throw new Error('Stream failed')

    messages.value.push({ from: 'assistant', content: '' })
    const msgIndex = messages.value.length - 1

    const reader = response.body.getReader()
    const decoder = new TextDecoder()

    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      const chunk = decoder.decode(value)
      for (const char of chunk) {
        assistantContent += char
        messages.value[msgIndex].content = assistantContent
        await new Promise(resolve => setTimeout(resolve,0))
      }
    }

  } catch (e) {
    console.error(e)
    messages.value.push({ from: 'assistant', content: '[Error during response streaming]' })
  } finally {
    loading.value = false
    controller = null
  }
}

function stopGeneration() {
  if (controller) controller.abort()
}

onUpdated(async () => {
  await nextTick()
  if (container.value) {
    container.value.scrollTop = container.value.scrollHeight
  }
})

</script>

<style scoped>
@keyframes bounce-delay {
  0%, 80%, 100% { transform: translateY(0); }
  40% { transform: translateY(-4px); }
}
.animate-bounce-delay-0 { animation: bounce-delay 1s infinite; }
.animate-bounce-delay-200 { animation: bounce-delay 1s infinite 0.2s; }
.animate-bounce-delay-400 { animation: bounce-delay 1s infinite 0.4s; }

.flex-1::-webkit-scrollbar { width: 6px; }
.flex-1::-webkit-scrollbar-thumb { background-color: rgba(100,100,100,0.4); border-radius: 3px; }
</style>
